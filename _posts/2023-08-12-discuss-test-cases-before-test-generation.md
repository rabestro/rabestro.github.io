---
title: "Discuss test cases before test generation"
date: 2023-08-12
categories: [AI, Testing]
tags: [ai, java, unit-test, blackbox, whitebox]     # TAG names should always be lowercase
mermaid: true
---

# Test cases first!

## The problem

The main problem I encountered with the automatic generation of unit tests was sample test data. This problem was when testing with the white and black box approaches. Even though the test templates were quite good, the test data could contain errors or not cover some edge cases.

### An example

For example, I used a tiny but rather complex code for artificial intelligence - the class implementing flip-flop predicate.

<details>
<summary>The complete code of FlipFlopPredicate</summary>

```java
package com.epam.flipflop;

import java.util.function.Predicate;


public final class FlipFlopPredicate<T> implements Predicate<T> {
    private final Predicate<? super T> lhs;
    private final Predicate<? super T> rhs;
    boolean state;

    public FlipFlopPredicate(Predicate<? super T> lhs, Predicate<? super T> rhs) {
        this.lhs = lhs;
        this.rhs = rhs;
    }

    @Override
    public boolean test(final T value) {
        var result = state || lhs.test(value);
        state = result && !rhs.test(value);
        return result;
    }
}
```

</details>

This predicate models the behavior of the corresponding language construct in AWK or SED and the [two-dot flip-flop operator in Ruby](https://scoutapm.com/blog/ruby-flip-flop) and [Perl](https://blog.geekuni.com/2016/03/perl-flip-flop.html).

When I just started using generative artificial intelligence and asked him to _"generate tests,"_ I rarely got a working version. If you run a test, it will fail. Its completely incorrect test data is due to the inability of artificial intelligence to analyze the program code. The poor quality of the testing data is mainly due to the lack of context. No JavaDoc explains the behavior of the predicate, and using predicate abbreviations like LHS and RHS exacerbates the issue. As a result, AI makes incorrect assumptions and provides inaccurate test data.

<details>
<summary>The typical unit test generated by AI</summary>

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class FlipFlopPredicateTest {

    @Test
    public void testTrueFalse() {
        FlipFlopPredicate<Integer> predicate = new FlipFlopPredicate<>(x -> x > 0, x -> x < 10);
        
        assertTrue(predicate.test(5));  // First condition (lhs) is true, second condition (rhs) is false
        assertFalse(predicate.test(15)); // Both conditions are false
        assertTrue(predicate.test(7));  // First condition (lhs) is true, second condition (rhs) is false
        assertFalse(predicate.test(3));  // Both conditions are true
    }

    @Test
    public void testFalseTrue() {
        FlipFlopPredicate<String> predicate = new FlipFlopPredicate<>(s -> s.length() < 5, s -> s.contains("a"));
        
        assertTrue(predicate.test("abcd"));   // First condition (lhs) is true, second condition (rhs) is false
        assertFalse(predicate.test("apple"));  // Both conditions are true
        assertTrue(predicate.test("xyz"));    // First condition (lhs) is true, second condition (rhs) is false
        assertFalse(predicate.test("banana")); // Both conditions are false
    }
}

```
</details>


The DiffBlue program generates unit tests that pass and achieve 100% code coverage. But are these tests good? Not really. Unfortunately, the DiffBlue system creates the illusion of good tests but not good ones. We can change the behavior of our predicate, and the tests will also pass successfully and show 100% coverage. If the predicate now models the behavior of a two-dot Rubi operator and we change that behavior to that of a three-dot operator, these tests will still pass. But it will be a completely different behavior. If our only goal in testing is to achieve 100% coverage, then we can use the DiffBlue program. If we aim to prevent errors and preserve the system's behavior, I will refrain from recommending such a program.

<details>
<summary>The unit tests generated by DiffBlue</summary>

```java
package com.epam.flipflop;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.function.Predicate;

import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

class FlipFlopPredicateDiffblueTest {
    /**
     * Method under test: {@link FlipFlopPredicate#FlipFlopPredicate(Predicate, Predicate)}
     */
    @Test
    void testConstructor() {
        // Arrange
        Predicate<Object> lhs = mock(Predicate.class);
        Predicate<Object> rhs = mock(Predicate.class);

        // Act
        FlipFlopPredicate<Object> actualFlipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);

        // Assert
        assertFalse(actualFlipFlopPredicate.state);
    }

    /**
     * Method under test: {@link FlipFlopPredicate#test(Object)}
     */
    @Test
    void testTest() {
        // Arrange
        Predicate<Object> lhs = mock(Predicate.class);
        when(lhs.test(Mockito.<Object>any())).thenReturn(true);
        Predicate<Object> rhs = mock(Predicate.class);
        when(rhs.test(Mockito.<Object>any())).thenReturn(true);
        FlipFlopPredicate<Object> flipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);
        String string = "Value";

        // Act
        boolean actualTestResult = flipFlopPredicate.test(string);

        // Assert
        assertTrue(actualTestResult);
        verify(lhs).test(Mockito.<Object>any());
        verify(rhs).test(Mockito.<Object>any());
        assertFalse(flipFlopPredicate.state);
    }

    /**
     * Method under test: {@link FlipFlopPredicate#test(Object)}
     */
    @Test
    void testTest2() {
        // Arrange
        Predicate<Object> lhs = mock(Predicate.class);
        when(lhs.test(Mockito.<Object>any())).thenReturn(false);
        Predicate<Object> rhs = mock(Predicate.class);
        when(rhs.test(Mockito.<Object>any())).thenReturn(true);
        FlipFlopPredicate<Object> flipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);
        String string = "Value";

        // Act
        boolean actualTestResult = flipFlopPredicate.test(string);

        // Assert
        assertFalse(actualTestResult);
        verify(lhs).test(Mockito.<Object>any());
        assertFalse(flipFlopPredicate.state);
    }

    /**
     * Method under test: {@link FlipFlopPredicate#test(Object)}
     */
    @Test
    void testTest3() {
        // Arrange
        Predicate<Object> lhs = mock(Predicate.class);
        when(lhs.test(Mockito.<Object>any())).thenReturn(true);
        Predicate<Object> rhs = mock(Predicate.class);
        when(rhs.test(Mockito.<Object>any())).thenReturn(false);
        FlipFlopPredicate<Object> flipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);
        String string = "Value";

        // Act
        boolean actualTestResult = flipFlopPredicate.test(string);

        // Assert
        assertTrue(actualTestResult);
        verify(lhs).test(Mockito.<Object>any());
        verify(rhs).test(Mockito.<Object>any());
        assertTrue(flipFlopPredicate.state);
    }

    /**
     * Method under test: {@link FlipFlopPredicate#test(Object)}
     */
    @Test
    void testTest4() {
        // Arrange
        Predicate<Object> lhs = mock(Predicate.class);
        when(lhs.test(Mockito.<Object>any())).thenReturn(true);
        Predicate<Object> rhs = mock(Predicate.class);
        when(rhs.test(Mockito.<Object>any())).thenReturn(false);

        FlipFlopPredicate<Object> flipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);
        flipFlopPredicate.test(0);
        String string = "42";

        // Act
        boolean actualTestResult = flipFlopPredicate.test(string);

        // Assert
        assertTrue(actualTestResult);
        verify(lhs).test(Mockito.<Object>any());
        verify(rhs, atLeast(1)).test(Mockito.<Object>any());
        assertTrue(flipFlopPredicate.state);
    }
}
```

</details>

## The solution

The idea arose that before generating tests, it is necessary to discuss test cases with artificial intelligence and, if necessary, correct or supplement them.

I decided to start with the white box approach. I added the following sentences to my already significant prompt to implement this idea:
> Your first step is to generate test cases and ask me if they are good. Please print these test cases as a table. When I confirm that the test cases are good, come to the second step and generate the test code.

## Proof of concept

I tested my prompt on two AI systems, ChatGPT4 and AI Assistant. ChatGPT4 correctly generated test cases on the first attempt, while AI Assistant required some adjustments before generating the test code. Here are the complete conversations.

### The perfect scenario

I tested my prompt on ChatGPT 4, but note that it works on other systems like Jetbrains' AI assistant or Microsoft Copilot. I set up a system prompt and then paste the code for testing. The result exceeded all my expectations. The test data suggested by artificial intelligence was accurate from the start, without any errors! The same applies to generated code. I didn't have anything to add to it.
In conclusion, I wanted to make sure that this is not an accident, but artificial intelligence created a test class following the instructions that I indicated in the system prompt. So I asked it to provide the report. Below is the whole dialogue.

<details>
<summary>Here is the complete conversation with ChatGPT4.</summary>

**User:**
`I posted the code.`

**ChatGPT 4:**
Before generating the test code, I have prepared the test cases for the `FlipFlopPredicate` class. Please review the test cases below:

| Test Case ID | Description                          | lhs.test() | rhs.test() | Initial State | Input | Expected Output | Expected State |
|--------------|--------------------------------------|------------|------------|---------------|-------|-----------------|----------------|
| 1            | Both lhs and rhs are false           | false      | false      | false         | any   | false           | false          |
| 2            | lhs is true, rhs is false            | true       | false      | false         | any   | true            | true           |
| 3            | lhs is false, rhs is true            | false      | true       | false         | any   | false           | false          |
| 4            | Both lhs and rhs are true            | true       | true       | false         | any   | true            | false          |
| 5            | Both lhs and rhs are false (state)   | false      | false      | true          | any   | true            | true           |
| 6            | lhs is true, rhs is false (state)    | true       | false      | true          | any   | true            | true           |
| 7            | lhs is false, rhs is true (state)    | false      | true       | true          | any   | true            | false          |
| 8            | Both lhs and rhs are true (state)    | true       | true       | true          | any   | true            | false          |

Please let me know if these test cases are good, and I will proceed with generating the test code.

**User:**
yes

**ChatGPT 4:**
Great! Now I will generate the test code for the `FlipFlopPredicate` class based on the approved test cases.

```java
package com.epam.flipflop;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.function.Predicate;

import static org.assertj.core.api.Assertions.assertThat;

class FlipFlopPredicateWhiteBoxC4Test {

    @DisplayName("Test FlipFlopPredicate with different lhs and rhs predicates and initial state")
    @ParameterizedTest(name = "Test case {0}: lhs.test()={1}, rhs.test()={2}, initial state={3}, input={4}, expected output={5}, expected state={6}")
    @CsvSource(delimiter = '|', textBlock = """
        1 | false | false | false | any | false | false
        2 | true  | false | false | any | true  | true
        3 | false | true  | false | any | false | false
        4 | true  | true  | false | any | true  | false
        5 | false | false | true  | any | true  | true
        6 | true  | false | true  | any | true  | true
        7 | false | true  | true  | any | true  | false
        8 | true  | true  | true  | any | true  | false
    """)
    void testFlipFlopPredicate(int testCaseId, boolean lhsResult, boolean rhsResult, boolean initialState, String input, boolean expectedOutput, boolean expectedState) {
        Predicate<String> lhs = s -> lhsResult;
        Predicate<String> rhs = s -> rhsResult;
        var flipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);
        flipFlopPredicate.state = initialState;

        var actualOutput = flipFlopPredicate.test(input);

        assertThat(actualOutput)
                .as("Test case %d: expected output is %b", testCaseId, expectedOutput)
                .isEqualTo(expectedOutput);
        assertThat(flipFlopPredicate.state)
                .as("Test case %d: expected state is %b", testCaseId, expectedState)
                .isEqualTo(expectedState);
    }
}
```

The generated test code follows all the requirements listed initially. It uses JUnit 5 framework with AssertJ assertions, `@DisplayName` annotation, and `@CsvSource` annotation with a customized delimiter and text block. The test class name ends with the suffix `WhiteBoxC4Test`, and it is in the same package as the code under test. The test cases cover all possible combinations of lhs and rhs predicates and the initial state, ensuring high coverage.

**User:**
Perfect! Please analyze the test generated by you for compliance with all the requirements listed initially and provide a report.

**ChatGPT 4:**
I have analyzed the generated test code for the `FlipFlopPredicate` class, and here is the report on its compliance with the initial requirements:

1. JUnit 5 framework with AssertJ assertions: The test code uses JUnit 5's `@DisplayName`, `@ParameterizedTest`, and `@CsvSource` annotations, along with AssertJ's `assertThat` method for assertions.

2. `@DisplayName` annotation: The test class and the test method both have the `@DisplayName` annotation, providing a clear description of the test purpose.

3. Customized display names for parameterized tests: The `@ParameterizedTest` annotation has a custom name attribute that includes the test case ID and the input parameters, making it easy to identify each test case.

4. `@CsvSource` annotation with delimiter and textBlock: The test method uses the `@CsvSource` annotation with a custom delimiter `|` and a text block for better readability.

5. Alignment of delimiters inside textBlock: The delimiters inside the text block are aligned to improve readability.

6. Usage of ' instead of " inside textBlock: The text block uses single quotes (') instead of double quotes (").

7. Usage of `var` keyword: The test code uses the `var` keyword instead of the fully qualified type name.

8. Omission of the public modifier: The test class, test methods, and lifecycle methods do not have the public modifier.

9. Test class name with the suffix `WhiteBoxC4Test`: The test class name ends with the required suffix `WhiteBoxC4Test`.

10. Test class in the same package as the code under test: The test class is in the same package (`com.epam.flipflop`) as the code under test.

11. Coverage of different techniques: The test cases cover Edge Coverage, Branch Coverage, Condition Coverage, Multiple Condition coverage, Path coverage, and State coverage by testing all possible combinations of lhs and rhs predicates and the initial state.

In conclusion, the generated test code for the `FlipFlopPredicate` class complies with all the initial requirements, ensuring high-quality, readable, and maintainable tests.

</details>

<details>
<summary>Here are some screenshots of the conversation.</summary>

I set the temperature to zero to ensure consistent results each time I run.

<img width="562" alt="image" src="https://github.com/rabestro/ai-unit-tests-08-2023/assets/52966251/bffa32fa-c7a1-4e98-b146-80d6d9f4a283">

Once the system prompt is set, starting the dialog is as simple as copying the code snippet.

<img width="537" alt="image" src="https://github.com/rabestro/ai-unit-tests-08-2023/assets/52966251/c888d9f3-0fbb-4ead-812d-310620f6438e">

</details>

### The scenario with some adjustments

For the second scenario, I created a prompt for the AI assistant provided by JetBrains.

<details>
<summary>The screenshots of the User Prompts Library.</summary>

<img width="1377" alt="image" src="https://github.com/rabestro/ai-unit-tests-08-2023/assets/52966251/667f8d45-be1d-40d1-b02e-045fcc2b987c">

</details>

On the first attempt, the AI assistant generated four test cases. I requested cases to be added црут `lhs` returns false. The AI then completed the missing four cases but made an inaccuracy in the last comment. I noted the error, and it was promptly corrected. After that, the AI successfully generated the tests. I then requested an additional check for the internal state, and the tests turned out to be excellent.


<details>
<summary>Here is the complete conversation with AI Assistant.</summary>

**User:**
_I posted the code_

**Assistant:**
Here are the test cases for the provided code. We will resolve it in two phases:

**Phase 1:** Check when state = false            
**Phase 2:** Check when state = true

For each phase, there will be two test cases:


**When LHS returns true and RHS returns false**               
**When LHS returns true and RHS returns true**

Test Cases:

| Scenario | Starting State | LHS Output | RHS Output | Expected Output | Comments |
| -------- | -------------- | ---------- | ---------- | --------------- | -------- |
| Case1    | false          | true       | false      | true            | As LHS returns true, State should be true. As RHS returns false, State should not change|
| Case2    | false          | true       | true       | true            | As LHS returns true, state should become True. However, As RHS also returns true, State should revert back to false |
| Case3    | true           | true       | false      | true            | As State is already true, it should remain true. RHS returning false has no effect on State         |
| Case4    | true           | true       | true       | true            | As State is already true, even though RHS returning True should make State false, the overall output remains true |

The test cases cover all the possible scenarios for this piece of code, please confirm if these are correct for further implementation of unit testing in JUnit 5.

**User:**
please add cases when lhs returns false

Assistant:
Thank you for the feedback. Here are the additional test cases when LHS returns `false`:

**Phase 3:** Check when state = false            
**Phase 4:** Check when state true

Each phase covers two cases:

**When LHS returns false and RHS returns false**               
**When LHS returns false and RHS returns true**

Test Cases:

| Scenario | Starting State | LHS Output | RHS Output | Expected Output | Comments |
| -------- | -------------- | ---------- | ---------- | --------------- | -------- |
| Case1    | false          | true       | false      | true            | As LHS returns true, State should be true. As RHS returns false, State should not change|
| Case2    | false          | true       | true       | true            | As LHS returns true, state should become True. However, As RHS also returns true, State should revert back to false |
| Case3    | true           | true       | false      | true            | As State is already true, it should remain true. RHS returning false has no effect on State|
| Case4    | true           | true       | true       | true            | As State is already true, even though RHS returning True should make State false, the overall output remains true |
| Case5    | false          | false      | false      | false           | As LHS returns false, State remains false. RHS has no effect |
| Case6    | false          | false      | true       | false           | As LHS returns false, State remains false. RHS has no effect |
| Case7    | true           | false      | false      | true            | As State is true, it should remain true despite LHS returning false. RHS has no effect |
| Case8    | true           | false      | true       | true            | As State is true, it should remain true despite LHS returning false. RHS has no effect |

Please confirm these additional cases are correct for further implementation.

**User:**
all test cases are correct. however for the test case8 the comment is incorrect. The state should revert back to false.

**Assistant:**
You're correct, I apologize for the oversight. Here's the corrected version of the test case:

| Scenario | Starting State | LHS Output | RHS Output | Expected Output | Comments |
| -------- | -------------- | -----------| ---------- | --------------- | -------- |
| Case1    | false          | true       | false      | true            | As LHS returns true, State should be true. As RHS returns false, State should not change|
| Case2    | false          | true       | true       | true            | As LHS returns true, state should become True. However, As RHS also returns true, State should revert back to false |
| Case3    | true           | true       | false      | true            | As State is already true, it should remain true. RHS returning false has no effect on State |
| Case4    | true           | true       | true       | true            | As State is already true, even though RHS returning True should make State false, the overall output remains true |
| Case5    | false          | false      | false      | false           | As LHS returns false, State remains false. RHS has no effect |
| Case6    | false          | false      | true       | false           | As LHS returns false, State remains false. RHS has no effect |
| Case7    | true           | false      | false      | true            | As State is true, it should remain true despite LHS returning false. RHS has no effect |
| Case8    | true           | false      | true       | true            | As State is true and LHS returns false, the output remains true. However, as RHS returns true, State should revert back to false |

Thank you for your attention to detail. Shall I proceed to create the JUnit test cases now?

**User:**
yes, please

**Assistant:**
Great! Here's the generated unit test code for testing the `FlipFlopPredicate` using JUnit 5 and AssertJ assertions:

```java
package com.epam.flipflop;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.function.Predicate;

class FlipFlopPredicateWhiteBoxAiTest {
    @DisplayName("Evaluates flip-flop predicate:")
    @ParameterizedTest(name = "[{index}] with state {0}, LHS {1}, RHS {2} it should return {3}")
    @CsvSource(delimiter = '|', textBlock =
            """
            false | true  | false | true
            false | true  | true  | true
            true  | true  | false | true
            true  | true  | true  | true
            false | false | false | false
            false | false | true  | false
            true  | false | false | true
            true  | false | true  | true
            """
    )
    void evaluatesFlipFlopPredicate(
            boolean initState,
            boolean lhsOutput,
            boolean rhsOutput,
            boolean expectedOutput
    ) {
        Predicate<Object> lhs = x -> lhsOutput;
        Predicate<Object> rhs = x -> rhsOutput;
        var flipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);
        flipFlopPredicate.state = initState;
        
        var actualOutput = flipFlopPredicate.test(null);

        assertThat(actualOutput)
                .as("When State is %s, LHS Output is %s and RHS Output is %s, then expected output should be %s", initState, lhsOutput, rhsOutput, expectedOutput)
                .isEqualTo(expectedOutput);
    }
}
```

In terms of compliance with all the initial requirements:

- JUnit 5 is used with AssertJ assertions
- The usage of `@DisplayName` annotation is in accordance with the requirements
- Customized display names are provided for the parameterized tests
- `@CsvSource` annotation is used for primitive types
- Use of `var` keyword is adhered to.
- Omitted public modifier for test classes, test methods.
- The test class name ends with the suffix `WhiteBoxAiTest`
- The test class is in the same package as the code under test
- The various aspects of coverage like Branch Coverage, Condition Coverage, Path Coverage and State Coverage are taken care of by covering every possible scenario for the given code block.

The test set now provides a full test coverage for the `FlipFlopPredicate`. If there are any modifications needed, feel free to let me know.

**User:**
please add an assertion for the state

**Assistant:**
Sure, I've now added an additional assertion to check the final `state` variable. Here is the updated Java test code:

```java
package com.epam.flipflop;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.function.Predicate;

class FlipFlopPredicateWhiteBoxAiTest {
    @DisplayName("Evaluates flip-flop predicate:")
    @ParameterizedTest(name = "[{index}] when state {0}, LHS {1}, RHS {2} it should return {3} and final state is {4}")
    @CsvSource(delimiter = '|', textBlock =
            """
            false | true  | false | true  | true
            false | true  | true  | true  | false
            true  | true  | false | true  | true
            true  | true  | true  | true  | false
            false | false | false | false | false
            false | false | true  | false | false
            true  | false | false | true  | true
            true  | false | true  | true  | false
            """
    )
    void evaluatesFlipFlopPredicate(
            boolean initState,
            boolean lhsOutput,
            boolean rhsOutput,
            boolean expectedOutput,
            boolean expectedState
    ) {
        Predicate<Object> lhs = x -> lhsOutput;
        Predicate<Object> rhs = x -> rhsOutput;
        var flipFlopPredicate = new FlipFlopPredicate<>(lhs, rhs);
        flipFlopPredicate.state = initState;

        var actualOutput = flipFlopPredicate.test(null);

        assertThat(actualOutput)
                .as("When State is %s, LHS Output is %s and RHS Output is %s, then expected output should be %s", initState, lhsOutput, rhsOutput, expectedOutput)
                .isEqualTo(expectedOutput);
        
        assertThat(flipFlopPredicate.state)
                .as("Final state should be %s", expectedState)
                .isEqualTo(expectedState);
    }
}
```

This test now checks that not only the function returns the correct output, but also that it changes the `state` variable as expected. Hope this meets your requirements. Please let me know if there are further modifications needed.

**User:**
You created an exceptional test!

**Assistant:**
Thank you! I'm glad to hear that you found the test to be exceptional. If there's anything else you need, feel free to ask. I'm here to help!

</details>

## Conclusion

The approach of discussing test cases with AI before generating test code appears promising. I plan to continue researching this topic further.
